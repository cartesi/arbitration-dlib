# Arbitration D-Lib

Arbritration DLib is the combination of the on-chain protocol and off-chain protocol that work together to resolve any disputes that might occur during the execution of a Cartesi Dapp. The behavior of the off-chain and on-chain code are very similar. The on-chain code is written in Solidity and the off-chain in Rust.

Most of the Solidity contracts in this repository follow the Instantiator design pattern.

## Compute Instantiator

A Compute contract is instantiated with a computation proposal. It's inital state, after being instantiated, is WaitingClaim. There is a deadline, therefore, for the Claimer to submit a result to the proposed computation.
After the Claimer submits a final hash for that proposal, there is a period in which the Challenger can either accept or challenge that result.

If the result is accepted we reach a Consensus state. If not, the dispute is resolved through a Verification Game.

The possible states of an instance of this contract are:

    // +---+
    // |   |
    // +---+
    //   |
    //   | instantiate
    //   v
    // +--------------+ claimVictoryByTime +-----------------------+
    // | WaitingClaim |------------------->| ClaimerMisseddeadline |
    // +--------------+                    +-----------------------+
    //   |
    //   | submitClaim
    //   v
    // +---------------------+  confirm    +-----------------+
    // | WaitingConfirmation |------------>| ConsensusResult |
    // +---------------------+ or deadline +-----------------+
    //   |
    //   | challenge
    //   v
    // +------------------+ winByVG        +---------------+
    // | WaitingChallenge |--------------->| ChallengerWon |
    // +------------------+                +---------------+
    //   |
    //   |
    //   |                  winByVG        +------------+
    //   +-------------------------------->| ClaimerWon |
    //                                     +------------+


## VG Instantiator

The Verification Game Instantiator is responsible for solving the disputes that may arise during the Compute Instantiator execution. It is evoked when a Claimed result gets challenged.

The first step of a Verification Game is finding the divergence point, which is done by the Partition Instantiator contract (detailed in the following section).

If the Partition Instantiator concludes successfully, the VG moves to the MemoryManager phase, in which the Claimer has to fill the MM with the activity log. This phase is also better described in a following section.

After the Memory Manager is filled with the necessary data, VG contract settles the game instantiating a machine and running one step on it.By checking the final hash generated by the step, the VG instantiator can define the winner. The Step transition is further explained in the[Solidity Machine Repo](https://github.com/cartesi/riscv-solidity).

These are the possible states and transitions of the contract.

    //
    //               +---+
    //               |   |
    //               +---+
    //                 |
    //                 | instantiate
    //                 v
    //               +----------------+  winByPartitionTimeout
    //   +-----------| WaitPartition  |------------------------+
    //   |           +----------------+                        |
    //   |                         |                           |
    //   | winByPartitionTimeout   | startMachineRunChallenge  |
    //   |                         v                           |
    //   |           +-----------------------+                 |
    //   | +---------| WaitMemoryProveValues |---------------+ |
    //   | |         +-----------------------+               | |
    //   | |                                                 | |
    //   | |claimVictoryByDeadline   settleVerificationGame  | |
    //   v v                                                 v v
    // +--------------------+               +-----------------------+
    // | FinishedClaimerWon |               | FinishedChallengerWon |
    // +--------------------+               +-----------------------+
    //

## Partition Instantiator

The Partition contract is responsible for the interactions between Alice and Bob while they find the divergence point (the exact step performed during the computation in which they agree with the inital hash but disagree with the final one).

The possible states of an instance of this contract are:

    //
    //          +---+
    //          |   |
    //          +---+
    //            |
    //            | instantiate
    //            v
    //          +---------------+  claimVictoryByTimeout  +---------------+
    //          | WaitingHashes |------------------------>| ChallengerWon |
    //          +---------------+                         +---------------+
    //            |  ^
    // replyQuery |  | makeQuery
    //            v  |
    //          +--------------+   claimVictoryByTimeout  +------------+
    //          | WaitingQuery |------------------------->| ClaimerWon |
    //          +--------------+                          +------------+
    //            |
    //            | presentDivergence
    //            v
    //          +-----------------+
    //          | DivergenceFound |
    //          +-----------------+
    //

## MemoryManager Instantiator

When a dispute arises and a machine run challenge begins, the Claimer is responsible to send their off-chain state access log to the MemoryManager instance referent to that Verification Game.

The information sent by them is consumed by the RISC-V Solidity emulator as if the entire state content was available - since the off and on-chain emulators match down to the order in which accesses are logged.

The MemoryManager contract offers the RISC-V Solidity emulator a very simple interface that consists of:

* read - reads a word in a specific address.
* write - writes a word in a specific address.
* finishReplayPhase - signals that the Step has completed.

It also makes sure that all accesses performed by the Step function match the ones provided by the Claimer and are consistent with the Merkle proofs provided by him. If that is not the case, the Claimer loses the dispute.

The possible states of an instance of this contract are:

    //
    // +---+
    // |   |
    // +---+
    //   |
    //   | instantiate
    //   v
    // +---------------+    | proveRead
    // | WaitingProofs |----| proveWrite
    // +---------------+
    //   |
    //   | finishProofPhase
    //   v
    // +----------------+    |read
    // | WaitingReplay  |----|write
    // +----------------+
    //   |
    //   | finishReplayPhase
    //   v
    // +----------------+
    // | FinishedReplay |
    // +----------------+
    //

## Getting Started - on-chain code

### Install

Install dependencies

    npm install

Compile contracts with

    ./node_modules/.bin/truffle compile

Having a node listening to 8545, you can deploy using

    ./node_modules/.bin/truffle deploy


### Run tests
Migrate contracts and prepare testing files
    ./prepare_python_tests.sh

Run tests
    ./run_python_tests.sh


## Getting Started - off-chain code

### Install

Install rust
    curl https://sh.rustup.rs -sSf | sh

Add cargo to your path in `.bashrc`
    export PATH=$PATH:/home/user/.cargo/bin

Move to compute dir:
    cd compute

Build project:
    cargo build

## TODO

Use safemath on contracts

Protect against replay attacks

Review if events are appropriate for light client


## Contributing

Pull requests are welcome. When contributing to this repository, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change.

Please note we have a code of conduct, please follow it in all your interactions with the project.

## Authors

* *Augusto Teixeira*

